from typing import List, Tuple, Optional, Dict, Any, Union, Callable

__version__: str

class Order:
    id: int
    side: str
    price: int
    original_quantity: int
    remaining_quantity: int
    filled_quantity: int
    status: str
    time_in_force: str
    timestamp: int

class Position:
    symbol: str
    quantity: int
    avg_entry_price: int
    total_cost: int
    realized_pnl: int
    def unrealized_pnl(self, price: int) -> int: ...

class Event:
    kind: str
    def __getstate__(self) -> str: ...
    def __setstate__(self, state: str) -> None: ...

class Trade:
    trade_id: int
    price: int
    quantity: int
    aggressor_side: str
    aggressor_order_id: int
    passive_order_id: int
    timestamp: int
    @property
    def price_float(self) -> float: ...

class LevelSnapshot:
    price: int
    quantity: int
    order_count: int
    @property
    def price_float(self) -> float: ...

class BookSnapshot:
    @property
    def bids(self) -> List[LevelSnapshot]: ...
    @property
    def asks(self) -> List[LevelSnapshot]: ...
    def imbalance(self) -> Optional[float]: ...
    def weighted_mid(self) -> Optional[float]: ...
    def mid_price(self) -> Optional[float]: ...
    def spread(self) -> Optional[int]: ...

class SubmitResult:
    order_id: int
    status: str
    filled_quantity: int
    resting_quantity: int
    cancelled_quantity: int
    @property
    def trades(self) -> List[Trade]: ...

class CancelResult:
    success: bool
    cancelled_quantity: int
    error: Optional[str]

class ModifyResult:
    success: bool
    old_order_id: int
    new_order_id: Optional[int]
    cancelled_quantity: int
    error: Optional[str]
    @property
    def trades(self) -> List[Trade]: ...

class StopSubmitResult:
    order_id: int
    status: str

class Metrics:
    total_return: float
    cagr: float
    volatility: float
    sharpe: float
    sortino: float
    max_drawdown: float
    calmar: float
    num_periods: int
    winning_periods: int
    losing_periods: int

class BacktestResult:
    portfolio: 'Portfolio'
    metrics: Optional[Metrics]

class CostModel:
    def __init__(self, commission_bps: int = 0, slippage_bps: int = 0, min_trade_fee: int = 0) -> None: ...
    @staticmethod
    def zero() -> 'CostModel': ...
    def compute_cost(self, notional: int) -> int: ...

class Portfolio:
    def __init__(self, initial_cash: int, cost_model: CostModel) -> None: ...
    @property
    def cash(self) -> int: ...
    def position(self, symbol: str) -> Optional[Position]: ...
    def positions(self) -> Dict[str, Position]: ...
    def total_equity(self, prices: List[Tuple[str, int]]) -> int: ...
    def current_weights(self, prices: List[Tuple[str, int]]) -> List[Tuple[str, float]]: ...
    def returns(self) -> List[float]: ...
    def equity_curve(self) -> List[int]: ...
    def rebalance_simple(self, targets: List[Tuple[str, float]], prices: List[Tuple[str, int]]) -> None: ...
    def rebalance_lob(self, targets: List[Tuple[str, float]], exchanges: 'MultiExchange') -> None: ...
    def record_return(self, prices: List[Tuple[str, int]]) -> None: ...
    def snapshot(self, prices: List[Tuple[str, int]]) -> Dict[str, Any]: ...
    def compute_metrics(self, periods_per_year: float, risk_free: float) -> Optional[Metrics]: ...
    def save_json(self, path: str) -> None: ...
    @staticmethod
    def load_json(path: str) -> 'Portfolio': ...

class Exchange:
    def __init__(self) -> None: ...
    @staticmethod
    def replay(events: List[Event]) -> 'Exchange': ...
    def submit_limit(self, side: str, price: int, quantity: int, tif: str = "gtc") -> SubmitResult: ...
    def submit_market(self, side: str, quantity: int) -> SubmitResult: ...
    def cancel(self, order_id: int) -> CancelResult: ...
    def modify(self, order_id: int, new_price: int, new_quantity: int) -> ModifyResult: ...
    def submit_stop_market(self, side: str, stop_price: int, quantity: int) -> StopSubmitResult: ...
    def submit_stop_limit(self, side: str, stop_price: int, limit_price: int, quantity: int, tif: str = "gtc") -> StopSubmitResult: ...
    def submit_trailing_stop_market(self, side: str, initial_stop_price: int, quantity: int, trail_type: str, trail_value: float, atr_period: Optional[int] = None) -> StopSubmitResult: ...
    def submit_trailing_stop_limit(self, side: str, initial_stop_price: int, limit_price: int, quantity: int, trail_type: str, trail_value: float, tif: str = "gtc", atr_period: Optional[int] = None) -> StopSubmitResult: ...
    def get_order(self, order_id: int) -> Optional[Order]: ...
    def get_stop_order(self, order_id: int) -> Optional[Dict[str, Any]]: ...
    def best_bid_ask(self) -> Tuple[Optional[int], Optional[int]]: ...
    def best_bid(self) -> Optional[int]: ...
    def best_ask(self) -> Optional[int]: ...
    def spread(self) -> Optional[int]: ...
    def last_trade_price(self) -> Optional[int]: ...
    def trades(self) -> List[Trade]: ...
    def events(self) -> List[Event]: ...
    def depth(self, levels: int = 10) -> BookSnapshot: ...
    def full_book(self) -> BookSnapshot: ...
    def pending_stop_count(self) -> int: ...
    def clear_trades(self) -> None: ...
    def clear_order_history(self) -> int: ...
    def compact(self) -> None: ...

class MultiExchange:
    def __init__(self) -> None: ...
    def get_or_create(self, symbol: str) -> Exchange: ...
    def symbols(self) -> List[str]: ...
    def best_prices(self) -> List[Tuple[str, Optional[int], Optional[int]]]: ...
    def submit_limit(self, symbol: str, side: str, price: int, quantity: int, tif: str = "gtc") -> SubmitResult: ...
    def submit_market(self, symbol: str, side: str, quantity: int) -> SubmitResult: ...
    def cancel(self, symbol: str, order_id: int) -> CancelResult: ...
    def modify(self, symbol: str, order_id: int, new_price: int, new_quantity: int) -> ModifyResult: ...
    def len(self) -> int: ...

def compute_metrics(returns: List[float], periods_per_year: float = 252.0, risk_free: float = 0.0) -> Optional[Metrics]: ...
def sweep_equal_weight(price_series: List[List[Tuple[str, int]]], initial_cash: int, cost_model: CostModel, periods_per_year: float = 252.0, risk_free: float = 0.0) -> BacktestResult: ...
def run_backtest(strategy: Callable[[int, Dict[str, int], Portfolio], List[Tuple[str, float]]], price_series: List[Dict[str, int]], initial_cash: int, cost_model: CostModel, periods_per_year: float = 252.0, risk_free: float = 0.0) -> BacktestResult: ...
def parse_itch(path: str) -> List[Tuple[str, Event]]: ...
